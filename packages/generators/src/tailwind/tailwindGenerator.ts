import { logger } from "@clafoutis/shared";
import fs from "fs";
import path from "path";
import StyleDictionary from "style-dictionary";
import {
  logBrokenReferenceLevels,
  logVerbosityLevels,
  logWarningLevels,
} from "style-dictionary/enums";
import type { DesignToken } from "style-dictionary/types";
import { fileHeader } from "style-dictionary/utils";
import tinycolor from "tinycolor2";

// 0) CLEAN OUTPUT DIRECTORY
// ----------------------------------------------------------------------------
function cleanDist(cwd: string): void {
  const distDir = path.resolve(cwd, "build/tailwind");
  try {
    fs.rmSync(distDir, { recursive: true, force: true });
    logger.info(`Removed ${distDir}`);
  } catch (err) {
    logger.error(`Failed to remove ${distDir}: ${err}`);
  }

  fs.mkdirSync(distDir, { recursive: true });
  logger.success(`Created fresh ${distDir}`);
}

// 1) TRANSFORMERS
// ----------------------------------------------------------------------------
/**
 * Transforms color values to space-separated RGB values
 * e.g. "#FF0000" -> "255 0 0"
 * Preserves alpha channel using modern CSS syntax: "0 0 0 / 0.5"
 */
StyleDictionary.registerTransform({
  name: "color/spaceRGB",
  type: "value",
  filter: (token: DesignToken) => token.$type === "color",
  transform: (token: DesignToken) => {
    const { r, g, b, a } = tinycolor(token.$value).toRgb();
    if (a < 1) {
      return `${r} ${g} ${b} / ${a}`;
    }
    return `${r} ${g} ${b}`;
  },
});

/**
 * Transforms token paths to kebab-case while preserving camelCase
 * e.g. ["text", "fontSize", "sm"] -> "text-fontSize-sm"
 */
StyleDictionary.registerTransform({
  name: "name/kebabWithCamel",
  type: "name",
  transform: (token: DesignToken) => token.path.join("-"),
});

/**
 * Converts camelCase to kebab-case
 * e.g. "fontSize" -> "font-size"
 */
function toKebabCase(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}

/**
 * Transforms a dimension value or space-separated list of dimensions to pixel values
 * @param {string|number} value - The dimension value(s) to transform
 * @returns {string} Space-separated list of pixel values
 */
function formatPixels(value: string | number): string {
  return parseSpaceSeparatedValues(value).map(convertToPixels).join(" ");
}

/**
 * Converts a single value to a pixel value
 * @param {string|number} value - The value to convert
 * @returns {string} The value with 'px' suffix if numeric
 */
function convertToPixels(value: string | number): string {
  const num = parseFloat(String(value));
  if (isNaN(num)) return String(value);
  if (num === 0) return "0px";
  return `${num}px`;
}

/**
 * Parses a value into an array of space-separated values
 * @param {string|number} value - The value to parse
 * @returns {string[]} Array of individual values
 */
function parseSpaceSeparatedValues(value: string | number): string[] {
  if (typeof value === "string" && value.includes(" ")) {
    return value.split(" ").filter(Boolean);
  }
  return [String(value)];
}

// Register the dimension transform
StyleDictionary.registerTransform({
  name: "dimension/px",
  type: "value",
  filter: (token: DesignToken) => token.original.$type === "dimension",
  transform: (token: DesignToken) => {
    const value = token.original.$value;
    if (value === undefined) return undefined;
    return formatPixels(value);
  },
});

// Some built-in transforms
const defaultTransforms = [
  "attribute/cti",
  "color/spaceRGB",
  "size/px",
  "name/kebab",
];

const tailwindTransforms = [
  "attribute/cti",
  "color/spaceRGB",
  "size/px",
  "name/kebabWithCamel",
];

StyleDictionary.registerTransformGroup({
  name: "custom/css",
  transforms: [
    "attribute/cti",
    "color/spaceRGB",
    "size/px",
    "name/kebab",
    "shadow/css/shorthand",
    "dimension/px",
  ],
});

// 2) FILE HEADERS
// ----------------------------------------------------------------------------
StyleDictionary.registerFileHeader({
  name: "doNotEditWarningHeader",
  fileHeader: async () => {
    const dateTime = new Date().toLocaleString();
    return [`Autogenerated file. Generated at ${dateTime}.`, "Do not edit!"];
  },
});

StyleDictionary.registerFileHeader({
  name: "canEditHeader",
  fileHeader: async () => {
    const dateTime = new Date().toLocaleString();
    return [
      `Autogenerated file. Generated at ${dateTime}.`,
      "This file can be edited to extend the base configuration.",
    ];
  },
});

// 3) A HELPER TO PRODUCE JS CODE WITH UNQUOTED KEYS
// ----------------------------------------------------------------------------
/**
 * Validates if a string is a valid JavaScript object key
 * @param {string} key - The key to validate
 * @returns {boolean} Whether the key is valid
 */
function isValidJSKey(key: string): boolean {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(key);
}

/**
 * Converts a value to a JavaScript literal representation
 * @param {any} value - The value to convert
 * @param {number} indent - The current indentation level
 * @returns {string} JavaScript literal representation
 */
function toJSLiteral(value: unknown, indent = 2): string {
  if (typeof value === "string") {
    return JSON.stringify(value);
  }
  if (Array.isArray(value)) {
    const arrContent = value.map((v) => toJSLiteral(v, indent + 2)).join(", ");
    return `[${arrContent}]`;
  }
  if (typeof value === "object" && value !== null) {
    const spaces = " ".repeat(indent);
    let result = "{\n";
    const entries = Object.entries(value);
    entries.forEach(([k, v], index) => {
      const keyName = isValidJSKey(k) ? k : JSON.stringify(k);
      result += `${spaces}${keyName}: ${toJSLiteral(v, indent + 2)}`;
      if (index < entries.length - 1) {
        result += ",";
      }
      result += "\n";
    });
    result += " ".repeat(indent - 2) + "}";
    return result;
  }
  return String(value);
}

/**
 * Sets a nested property in an object using an array of keys
 * @param obj - The target object
 * @param pathArray - Array of keys representing the path
 * @param value - The value to set (token values: strings, numbers, or nested objects)
 */
function setNestedProperty(
  obj: Record<string, unknown>,
  pathArray: string[],
  value: unknown,
): void {
  let current: Record<string, unknown> = obj;
  for (let i = 0; i < pathArray.length; i++) {
    const key = pathArray[i];
    if (i === pathArray.length - 1) {
      current[key] = value;
    } else {
      if (!current[key]) {
        current[key] = {};
      }
      current = current[key] as Record<string, unknown>;
    }
  }
}

// 4) FORMATTERS
// ----------------------------------------------------------------------------
/**
 * Generates the main CSS index file with imports and Tailwind directives
 */
StyleDictionary.registerFormat({
  name: "css/index-file",
  format: async function ({ file, options }) {
    const header = await fileHeader({ file, options });

    const content = `
/* Import Generated Design Token Files */
@import "./base.css";
@import "./dark.css";

/* Tailwind Base, Components, and Utilities */
@tailwind base;
@tailwind components;
@tailwind utilities;
`.trimStart();

    return header + content;
  },
});

/**
 * Generates the base Tailwind configuration with theme extensions
 */
StyleDictionary.registerFormat({
  name: "tailwind/base",
  format: async function ({ file, options, dictionary }) {
    const header = await fileHeader({ file, options });

    const partialConfig = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {},
        },
      },
    };

    // Insert tokens into partialConfig.theme.extend
    dictionary.allTokens.forEach((token) => {
      let cssRef;
      if (token?.$type === "color") {
        cssRef = `rgb(var(--${toKebabCase(token.name)}))`;
      } else {
        cssRef = `var(--${toKebabCase(token.name)})`;
      }

      // Map token names to Tailwind theme keys
      const segments = token.name.split("-");

      // "color" tokens should go into "colors" (Tailwind's expected key)
      if (segments[0] === "color") {
        const colorPath = ["colors", ...segments.slice(1)];
        setNestedProperty(partialConfig.theme.extend, colorPath, cssRef);
      } else {
        setNestedProperty(partialConfig.theme.extend, segments, cssRef);
      }
    });

    const partialStr = toJSLiteral(partialConfig, 2);
    return (
      header +
      `/** @type {import('tailwindcss').Config} */
export default ${partialStr};`
    );
  },
});

/**
 * Generates the main Tailwind configuration file
 */
StyleDictionary.registerFormat({
  name: "tailwind/config",
  format: async function ({ file, options }) {
    const header = await fileHeader({ file, options });

    return (
      header +
      `/** @type {import('tailwindcss').Config} */

import base from "./tailwind.base.js";

export default {
  darkMode: base.darkMode,

  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}"
  ],

  plugins: [
  ],

  theme: {
    ...base.theme,

    extend: {
      ...(base.theme?.extend || {}),
    }
  }
};`
    );
  },
});

// 5) BUILD SCRIPTS
// ----------------------------------------------------------------------------
async function main(cwd: string = process.cwd()): Promise<void> {
  const resolvedCwd = path.resolve(cwd);
  const buildPath = path.join(resolvedCwd, "build", "tailwind") + "/";

  cleanDist(resolvedCwd);

  // Base styles
  {
    console.log("Building base theme...");
    const SD = new StyleDictionary({
      source: [
        path.join(resolvedCwd, "tokens/**/!(*.dark).json"), // all .json files that do NOT end with .dark.json
      ],
      log: {
        warnings: logWarningLevels.warn, // 'warn' | 'error' | 'disabled'
        verbosity: logVerbosityLevels.verbose, // 'default' | 'silent' | 'verbose'
        errors: {
          brokenReferences: logBrokenReferenceLevels.throw, // 'throw' | 'console'
        },
      },
      platforms: {
        // 1) CSS output
        base: {
          transformGroup: "custom/css",
          buildPath,
          files: [
            {
              destination: "base.css",
              format: "css/variables",
              options: {
                fileHeader: "doNotEditWarningHeader",
                outputReferences: true,
              },
            },
            {
              destination: "index.css",
              format: "css/index-file",
              options: {
                fileHeader: "canEditHeader",
              },
            },
          ],
        },
        // 2) Tailwind partial + merged configs in the repo root
        tailwind: {
          transformGroup: "js",
          transforms: tailwindTransforms,
          buildPath,
          files: [
            {
              destination: "tailwind.base.js",
              format: "tailwind/base",
              options: {
                fileHeader: "doNotEditWarningHeader",
              },
            },
            {
              destination: "tailwind.config.js",
              format: "tailwind/config",
              options: {
                fileHeader: "canEditHeader",
              },
            },
          ],
        },
      },
    });
    await SD.buildAllPlatforms();
    logger.success("Base theme built!");
  }

  // Dark styles - load dark tokens AFTER base tokens so dark values take precedence
  {
    console.log("Building dark theme...");
    const SD = new StyleDictionary({
      source: [
        // Order matters! Load base tokens first for reference resolution,
        // then dark tokens to override with dark-specific values
        path.join(resolvedCwd, "tokens/**/!(*.dark).json"),
        path.join(resolvedCwd, "tokens/**/*.dark.json"),
      ],
      log: {
        verbosity: logVerbosityLevels.default,
        warnings: logWarningLevels.disabled, // Disable collision warnings for dark build
      },
      platforms: {
        base: {
          transformGroup: "css",
          transforms: defaultTransforms,
          buildPath,
          files: [
            {
              destination: "dark.css",
              format: "css/variables",
              filter: (token) => token.filePath.includes(".dark.json"), // Only output dark tokens
              options: {
                fileHeader: "doNotEditWarningHeader",
                selector: ".dark",
                outputReferences: true,
              },
            },
          ],
        },
      },
    });
    await SD.buildAllPlatforms();
    logger.success("Dark theme built!");
  }

  logger.success("All builds finished!");
}

// Run directly if executed as script
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((err) => {
    console.error("Error building tokens:", err);
    process.exit(1);
  });
}

export { main };

// Plugin API compatibility
export const generate = main;
