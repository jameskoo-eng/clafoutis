import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { generateCommand } from '../../cli/commands/generate.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('Plugin System', () => {
  let tempDir: string;
  let originalCwd: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'clafoutis-plugin-'));
    originalCwd = process.cwd();
    process.chdir(tempDir);

    await fs.mkdir('tokens/colors', { recursive: true });
    await fs.writeFile('tokens/colors/primitives.json', JSON.stringify({
      colors: {
        primary: { $type: 'color', $value: '#3b82f6' }
      }
    }));
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await fs.rm(tempDir, { recursive: true });
  });

  it('loads and runs custom generator from path', async () => {
    await fs.mkdir('generators', { recursive: true });
    await fs.writeFile('generators/custom.js', `
      export const generate = async ({ outputDir }) => {
        const fs = await import('fs');
        fs.mkdirSync(outputDir, { recursive: true });
        fs.writeFileSync(outputDir + '/custom-output.txt', 'Generated by custom plugin');
      };
    `);

    await fs.mkdir('.clafoutis', { recursive: true });
    await fs.writeFile('.clafoutis/producer.json', JSON.stringify({
      tokens: './tokens',
      output: './build',
      generators: {
        'my-custom': './generators/custom.js'
      }
    }));

    await generateCommand({});

    const output = await fs.readFile('build/my-custom/custom-output.txt', 'utf-8');
    expect(output).toBe('Generated by custom plugin');
  });

  it('receives StyleDictionary in context', async () => {
    await fs.mkdir('generators', { recursive: true });
    await fs.writeFile('generators/sd-test.js', `
      export const generate = async ({ StyleDictionary, outputDir }) => {
        const fs = await import('fs');
        fs.mkdirSync(outputDir, { recursive: true });

        const hasRegisterTransform = typeof StyleDictionary.registerTransform === 'function';
        fs.writeFileSync(outputDir + '/sd-check.json', JSON.stringify({ hasRegisterTransform }));
      };
    `);

    await fs.mkdir('.clafoutis', { recursive: true });
    await fs.writeFile('.clafoutis/producer.json', JSON.stringify({
      tokens: './tokens',
      output: './build',
      generators: { 'sd-test': './generators/sd-test.js' }
    }));

    await generateCommand({});

    const check = JSON.parse(await fs.readFile('build/sd-test/sd-check.json', 'utf-8'));
    expect(check.hasRegisterTransform).toBe(true);
  });

  it('handles plugin errors gracefully', async () => {
    await fs.mkdir('generators', { recursive: true });
    await fs.writeFile('generators/broken.js', `
      export const generate = async () => {
        throw new Error('Intentional plugin error');
      };
    `);

    await fs.mkdir('.clafoutis', { recursive: true });
    await fs.writeFile('.clafoutis/producer.json', JSON.stringify({
      tokens: './tokens',
      output: './build',
      generators: { 'broken': './generators/broken.js' }
    }));

    await expect(generateCommand({})).resolves.not.toThrow();
  });

  it('receives config in context', async () => {
    await fs.mkdir('generators', { recursive: true });
    await fs.writeFile('generators/config-test.js', `
      export const generate = async ({ config, outputDir }) => {
        const fs = await import('fs');
        fs.mkdirSync(outputDir, { recursive: true });
        fs.writeFileSync(outputDir + '/config.json', JSON.stringify(config, null, 2));
      };
    `);

    await fs.mkdir('.clafoutis', { recursive: true });
    await fs.writeFile('.clafoutis/producer.json', JSON.stringify({
      tokens: './tokens',
      output: './build',
      generators: { 'config-test': './generators/config-test.js' }
    }));

    await generateCommand({});

    const savedConfig = JSON.parse(await fs.readFile('build/config-test/config.json', 'utf-8'));
    expect(savedConfig.tokens).toBe('./tokens');
    expect(savedConfig.output).toBe('./build');
  });

  it('receives tokensDir in context', async () => {
    await fs.mkdir('generators', { recursive: true });
    await fs.writeFile('generators/tokens-test.js', `
      export const generate = async ({ tokensDir, outputDir }) => {
        const fs = await import('fs');
        const path = await import('path');

        fs.mkdirSync(outputDir, { recursive: true });

        const files = fs.readdirSync(tokensDir, { recursive: true });
        fs.writeFileSync(outputDir + '/tokens-info.json', JSON.stringify({
          tokensDir,
          fileCount: files.length
        }));
      };
    `);

    await fs.mkdir('.clafoutis', { recursive: true });
    await fs.writeFile('.clafoutis/producer.json', JSON.stringify({
      tokens: './tokens',
      output: './build',
      generators: { 'tokens-test': './generators/tokens-test.js' }
    }));

    await generateCommand({});

    const info = JSON.parse(await fs.readFile('build/tokens-test/tokens-info.json', 'utf-8'));
    expect(info.tokensDir).toContain('tokens');
    expect(info.fileCount).toBeGreaterThan(0);
  });
});
